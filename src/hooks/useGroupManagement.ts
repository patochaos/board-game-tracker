'use client';

import { useState, useEffect, useCallback } from 'react';
import { createBrowserClient } from '@supabase/ssr';

// ============================================
// Types
// ============================================

export interface Group {
  id: string;
  invite_code: string;
  name: string;
  description: string | null;
  location: string | null;
  timezone: string | null;
  avatar_url: string | null;
  created_at: string;
  created_by: string;
}

export interface GroupMember {
  id: string;
  group_id: string;
  user_id: string;
  role: 'admin' | 'member';
  is_primary: boolean;
  joined_at: string;
  profile?: {
    id: string;
    username: string;
    display_name: string | null;
    avatar_url: string | null;
  };
}

export interface GroupWithMembership extends Group {
  role: 'admin' | 'member';
  is_primary: boolean;
  member_count: number;
}

export interface GroupGuest {
  id: string;
  group_id: string;
  name: string;
  created_at: string;
  created_by: string | null;
}

export interface CreateGroupInput {
  name: string;
  description?: string;
  location?: string;
  timezone?: string;
}

// ============================================
// Hook
// ============================================

export function useGroupManagement() {
  const [groups, setGroups] = useState<GroupWithMembership[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const supabase = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  // ============================================
  // Fetch all user's groups
  // ============================================
  const fetchGroups = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        setGroups([]);
        setLoading(false);
        return;
      }

      // Get user's memberships with group details
      const { data: memberships, error: memberError } = await supabase
        .from('group_members')
        .select(`
          id,
          role,
          is_primary,
          group:groups(*)
        `)
        .eq('user_id', user.id);

      if (memberError) throw memberError;

      // Get member counts for each group
      const groupsWithCounts: GroupWithMembership[] = await Promise.all(
        (memberships || [])
          .filter(m => m.group !== null)
          .map(async (m) => {
            const group = m.group as unknown as Group;
            const { count } = await supabase
              .from('group_members')
              .select('*', { count: 'exact', head: true })
              .eq('group_id', group.id);

            return {
              ...group,
              role: m.role as 'admin' | 'member',
              is_primary: m.is_primary ?? false,
              member_count: count || 0,
            };
          })
      );

      setGroups(groupsWithCounts);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch groups');
    } finally {
      setLoading(false);
    }
  }, [supabase]);

  useEffect(() => {
    fetchGroups();
  }, [fetchGroups]);

  // ============================================
  // Create a new group
  // ============================================
  const createGroup = async (input: CreateGroupInput): Promise<Group | null> => {
    setError(null);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Create the group (invite_code will be auto-generated by trigger)
      const { data: group, error: groupError } = await supabase
        .from('groups')
        .insert({
          name: input.name,
          description: input.description || null,
          location: input.location || null,
          timezone: input.timezone || null,
          created_by: user.id,
        })
        .select()
        .single();

      if (groupError) throw groupError;

      // Check if this is the user's first group
      const { count } = await supabase
        .from('group_members')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', user.id);

      const isFirstGroup = (count || 0) === 0;

      // Add creator as admin
      const { error: memberError } = await supabase
        .from('group_members')
        .insert({
          group_id: group.id,
          user_id: user.id,
          role: 'admin',
          is_primary: isFirstGroup,
        });

      if (memberError) throw memberError;

      await fetchGroups();
      return group;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create group';
      setError(message);
      return null;
    }
  };

  // ============================================
  // Join group by invite code
  // ============================================
  const joinGroupByCode = async (code: string): Promise<{ success: boolean; groupId?: string }> => {
    setError(null);
    try {
      // Clean the code (uppercase, remove dashes/spaces)
      const cleanCode = code.toUpperCase().replace(/[^A-Z0-9]/g, '');

      const { data, error } = await supabase.rpc('join_group_by_invite_code', {
        code: cleanCode,
      });

      if (error) throw error;

      await fetchGroups();
      return { success: true, groupId: data };
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to join group';
      setError(message);
      return { success: false };
    }
  };

  // ============================================
  // Lookup group by invite code (without joining)
  // ============================================
  const lookupGroupByCode = async (code: string): Promise<{
    id: string;
    name: string;
    description: string | null;
    location: string | null;
    member_count: number;
  } | null> => {
    setError(null);
    try {
      const cleanCode = code.toUpperCase().replace(/[^A-Z0-9]/g, '');

      const { data, error } = await supabase.rpc('get_group_by_invite_code', {
        code: cleanCode,
      });

      if (error) throw error;
      if (!data || data.length === 0) return null;

      return data[0];
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to lookup group';
      setError(message);
      return null;
    }
  };

  // ============================================
  // Leave a group
  // ============================================
  const leaveGroup = async (groupId: string): Promise<boolean> => {
    setError(null);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Check if user is the last admin
      const { data: admins } = await supabase
        .from('group_members')
        .select('user_id')
        .eq('group_id', groupId)
        .eq('role', 'admin');

      if (admins && admins.length === 1 && admins[0].user_id === user.id) {
        // Check if there are other members
        const { count } = await supabase
          .from('group_members')
          .select('*', { count: 'exact', head: true })
          .eq('group_id', groupId);

        if (count && count > 1) {
          throw new Error('You are the only admin. Promote another member before leaving.');
        }
        // If last member, allow leaving (group will be orphaned)
      }

      const { error } = await supabase
        .from('group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', user.id);

      if (error) throw error;

      await fetchGroups();
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to leave group';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Set primary group
  // ============================================
  const setPrimaryGroup = async (groupId: string): Promise<boolean> => {
    setError(null);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { error } = await supabase
        .from('group_members')
        .update({ is_primary: true })
        .eq('group_id', groupId)
        .eq('user_id', user.id);

      if (error) throw error;

      await fetchGroups();
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to set primary group';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Get group members
  // ============================================
  const getGroupMembers = async (groupId: string): Promise<GroupMember[]> => {
    try {
      const { data, error } = await supabase
        .from('group_members')
        .select(`
          id,
          group_id,
          user_id,
          role,
          is_primary,
          joined_at,
          profile:profiles(id, username, display_name, avatar_url)
        `)
        .eq('group_id', groupId)
        .order('role', { ascending: false }) // Admins first
        .order('joined_at', { ascending: true });

      if (error) throw error;
      return (data || []) as unknown as GroupMember[];
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch members';
      setError(message);
      return [];
    }
  };

  // ============================================
  // Promote member to admin
  // ============================================
  const promoteToAdmin = async (groupId: string, userId: string): Promise<boolean> => {
    setError(null);
    try {
      const { error } = await supabase
        .from('group_members')
        .update({ role: 'admin' })
        .eq('group_id', groupId)
        .eq('user_id', userId);

      if (error) throw error;
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to promote member';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Demote admin to member
  // ============================================
  const demoteToMember = async (groupId: string, userId: string): Promise<boolean> => {
    setError(null);
    try {
      // Check if this would leave no admins
      const { data: admins } = await supabase
        .from('group_members')
        .select('user_id')
        .eq('group_id', groupId)
        .eq('role', 'admin');

      if (admins && admins.length === 1 && admins[0].user_id === userId) {
        throw new Error('Cannot demote the only admin');
      }

      const { error } = await supabase
        .from('group_members')
        .update({ role: 'member' })
        .eq('group_id', groupId)
        .eq('user_id', userId);

      if (error) throw error;
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to demote admin';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Remove member from group
  // ============================================
  const removeMember = async (groupId: string, userId: string): Promise<boolean> => {
    setError(null);
    try {
      const { error } = await supabase
        .from('group_members')
        .delete()
        .eq('group_id', groupId)
        .eq('user_id', userId);

      if (error) throw error;
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to remove member';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Regenerate invite code
  // ============================================
  const regenerateInviteCode = async (groupId: string): Promise<string | null> => {
    setError(null);
    try {
      const { data, error } = await supabase.rpc('regenerate_invite_code', {
        target_group_id: groupId,
      });

      if (error) throw error;

      await fetchGroups();
      return data;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to regenerate code';
      setError(message);
      return null;
    }
  };

  // ============================================
  // Update group profile
  // ============================================
  const updateGroup = async (
    groupId: string,
    updates: Partial<Pick<Group, 'name' | 'description' | 'location' | 'timezone' | 'avatar_url'>>
  ): Promise<boolean> => {
    setError(null);
    try {
      const { error } = await supabase
        .from('groups')
        .update(updates)
        .eq('id', groupId);

      if (error) throw error;

      await fetchGroups();
      return true;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to update group';
      setError(message);
      return false;
    }
  };

  // ============================================
  // Guest management
  // ============================================
  const getGroupGuests = async (groupId: string): Promise<GroupGuest[]> => {
    try {
      const { data, error } = await supabase
        .from('group_guests')
        .select('*')
        .eq('group_id', groupId)
        .order('name', { ascending: true });

      if (error) throw error;
      return data || [];
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch guests';
      setError(message);
      return [];
    }
  };

  const createGroupGuest = async (groupId: string, name: string): Promise<GroupGuest | null> => {
    setError(null);
    try {
      const { data: { user } } = await supabase.auth.getUser();

      const { data, error } = await supabase
        .from('group_guests')
        .insert({
          group_id: groupId,
          name: name.trim(),
          created_by: user?.id || null,
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to create guest';
      setError(message);
      return null;
    }
  };

  // ============================================
  // Return values
  // ============================================
  return {
    // State
    groups,
    loading,
    error,
    primaryGroup: groups.find((g) => g.is_primary) || groups[0] || null,

    // Group operations
    createGroup,
    joinGroupByCode,
    lookupGroupByCode,
    leaveGroup,
    setPrimaryGroup,
    updateGroup,
    regenerateInviteCode,

    // Member operations
    getGroupMembers,
    promoteToAdmin,
    demoteToMember,
    removeMember,

    // Guest operations
    getGroupGuests,
    createGroupGuest,

    // Utility
    refresh: fetchGroups,
    clearError: () => setError(null),
  };
}
